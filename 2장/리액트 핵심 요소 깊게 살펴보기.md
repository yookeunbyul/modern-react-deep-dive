# 리액트 핵심 요소 깊게 살펴보기

### 2.1 JSX란?

XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법.

JSX는 페이스북이 임의로 만든 새로운 문법이기 때문에 JSX는 반드시 **트랜스파일러**를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미있는 자바스크립트 코드로 변환된다.

---

### 2.2 가상 DOM과 리액트 파이버

리액트는 가상 DOM을 운영한다.

#### 2.2.1 DOM과 브라우저 렌더링 과정

**DOM**은 웹페이지에 대한 인퍼테이스, 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

1. 브라우저가 사용자가 요청한 주소에 방문해 HTML을 다운로드

2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM을 만든다.

3. 브라우저의 렌더링 엔진은 CSS도 파싱해 CSSOM을 만든다.

4. DOM과 CSSOM을 가지고 렌더링 트리를 만든 후 노드와 스타일을 계산(레이아웃)

5. 페인트

#### 2.2.2 가상 DOM의 탄생 배경

렌더링이 완료된 후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황 O.

수정 => 레이아웃 => 리페인팅 이 수도없이 일어나야한다.

자식요소 역시 덩달아 변경돼야 하기 때문에 더 많은 비용을 브라우저와 사용자가 지불하게 된다. 또한 개발자가 계속 DOM의 모든 변경 사항을 추척하는 것이 너무 수고스러운..

"모든 DOM의 변경보다는 결과적으로 만들어지는 DOM 결과물 하나만 알고싶다." => 그래서 나온 것이 실제 브라우저의 DOM이 아닌 리액트가 관리하는 **가상 DOM**

가상 DOM은 일단 메모리에 저장하고 리액트에 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저 DOM에 반영한다.

"가상 DOM 방식이 무조건 빠른게 아니라 대부분의 상황에서 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠르다."

#### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 **리액트 파이버(React Fiber)** 다.

- 리액트 파이버란?

  : 리액트에서 관리하는 평범한 객체다.

  파이버는 파이버 재조정자가 관리하는데, 이는 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

  - 재조정 => 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

  - 그리고 이 모든 과정이 비동기로 일어난다는 것이다.

- 리액트 파이버 트리

  ![스크린샷 2024-03-28 172041](https://github.com/yookeunbyul/modern-react-deep-dive/assets/91243651/50a13a37-26c2-4fdb-b4c5-1ceb7e4e5d74)

  파이버 트리는 리액트 내부에서 두 개가 존재한다.

  현재 모습을 담은 파이버 트리, 작업 중인 상태를 나타내는 workInProgress 트리

  리액트 파이버의 작업이 끝나면 단순히 포인터를 변경해서 workInProgress 트리를 현재 트리로 바꿔버린다.

  => **더블 버퍼링**

#### 2.2.4 가상 DOM의 탄생 배경

리액트 컴포넌트에 대한 정보를 1 : 1로 가지고 있는 것이 파이버.

이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다. (재조정이 비동기적으로 이뤄진다.)

**하지만 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야해서, 화면에 불완전하게 표시될 수 있으므로 이러한 작업을 가상에서, 즉 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.**

```
빨라가서 가상 DOM을 사용하는 것이 아니라 값이 변경되고 업데이트 되는 것을 개발자가 모두 파악하고 수정하는 것이 어려우니, 내부적인 알고리즘을 통해 관리해 줌 으로써 대규모 웹 애플리케이션을 효율적으로 유지보수와 관리할 수 있어서 사용하는 것이다.
```

<br />

---

### 2.3 클래스 컴포넌트와 함수 컴포넌트

#### 2.3.1 클래스 컴포넌트

```
import React from 'react'

class SampleComponent extends React.Component {
    render() {
        return <h2>Sample Component</h2>
    }
}
```

<br />

- 클래스 컴포넌트의 생명주기 메서드

  생명주기 메서드가 실행되는 시점은 크게 3가지로 나뉜다.

  1. 마운트(mount) : 컴포넌트가 마운팅(생성)되는 시점

  2. 업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점

  3. 언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점

  ***

  - render()

    생명주기 메서드 중 하나로, 리액트 클래스 컴포넌트의 유일한 필수값

    render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다.

  - componentDidMount()

    클래스 컴포넌트가 마운트되고 준비가 됐다면 그다음으로 호출되는 생명주기 메서드

  - componentDidUpdate()

    컴포넌트 업데이트가 일어난 이후 바로 실행된다.

    state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다.

  - componentWillUnmount()

    컴포넌트가 언마운트되거나 더이상 사용되지 않기 직전에 호출된다.

    클린업 함수를 호출하기 위한 최적의 위치다.

  - shouldComponentUpdate()

    state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶다면 이 생명주기 메서드를 사용하면 된다.

    - Component vs PureComponent

      Component는 state 값(1에서 1로)이 업데이트 되는 대로 렌더링이 일어나지만,

      PureComponent는 state 값에 대해 얕은 비교를 수행해 결과가 다를 때만 렌더링을 수행한다.

---

<br />

- 클래스 컴포넌트의 한계

  - 데이터의 흐름을 추적하기 어렵다.

  - 애플리케이션 내부 로직의 재사용이 어렵다.

  - 기능이 많아 질수록 컴포넌트의 크기가 커진다.

  - 클래스는 함수에 비해 상대적으로 어렵다.

  - 코드 크기를 최적화하기 어렵다.

  - 핫 리로딩을 하는 데 상대적으로 불리하다.

    **핫 리로딩**이란,

    코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도

    해당 변경된 코드만 업데이트해 변경사항을 빠르게 적용하는 기법

<br />

---

#### 2.3.2 함수 컴포넌트

기존의 무상태 함수 컴포넌트에 상태를 더할 수 있는 훅을 출시해 함수 컴포넌트를 많은 사람들이 사용하게끔 유도한다.

```
import {useState} from 'react'

type = SampleProps = {
    required? : boolean
    text : string
}

export function SampleComponent({required, text} : SampleProps) {
    const [count, setCount] = useState<number>(0);
    const [isLimited, setIsLimited] = useState<boolean>(false)

    function handleClick() {
        const newValue = count + 1
        setCount(newValue)
        setIsLimited(newValue >= 10);
    }

    return (
        <h2>
            Sample Component
            <div>{required ? '필수' : '필수 아님'}</div>
            <div>문자: {text}</div>
            <div>count: {count}</div>
            <button onClick={handleClick} disabled={isLimited}>
                증가
            </button>
        </h2>
    )
}
```

#### 2.3.3 함수 컴포넌트 vs 클래스 컴포넌트

- 생명주기 메서드의 부재

  클래스 컴포넌트의 생명주기 메서드가 함수 컴포넌트에는 존재하지 않는다.

  useEffect 훅이 생명주기 메서드(마운트,업데이트,언마운트)를 비슷하게 구현하지만 똑같은 것은 아니다.

- 함수 컴포넌트와 렌더링된 값

  함수 컴포넌트는 렌더링 된 값을 고정하고, 클래스 컴포넌트는 그렇지 못한다.

  함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다.

  props와 state가 변경된다면, 다시 한 번 그 값을 기준으로 함수가 호출된다고 볼 수 있다.

  반면 클래스 컴포넌트는 **시간의 흐름에 따라 변화하는 this를 기준으로 렌더링**이 된다.

<br />

---

### 2.4 렌더링은 어떻게 일어나는가?

브라우저의 렌더링이란 쉽게 말해 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는과정을 의미한다.

렌더링이 어떻게 이뤄지느냐에 따라 성능에도 큰 영향을 미친다. 곧, 사용자에게 보여지는 정보를 그리는 과정이기 때문이다.

리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다.

#### 2.4.1 리액트의 렌더링이란?

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

#### 2.4.2 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링 : 처음 애플리케이션에 진입하면 최초 렌더링을 수행한다.

2. 리렌더링 : 최초 렌더링 이후로 발생하는 모든 렌더링을 의미한다.

리액트는 useState 등으로 관리되지 않는 단순한 변수는 제아무리 변경된다 하더라도 리렌더링을 발생시키지 않아 변경된 값을 렌더링된 DOM에서 확인할 수 없다.

#### 2.4.3 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.

발견하면 클래스 컴포넌트는 클래스 내부의 render() 함수를 실행하게 되고, 함수 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출한 뒤에 그 결과물을 저장한다.

재조정 과정(실제 DOM과 가상 DOM을 비교)이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

**리액트의 렌더링**은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다.

#### 2.4.4 렌더와 커밋

- 렌더 단계

  컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.

  재조정 과정에서 비교하는 것은 크게 세가지로, type, props, key다.

- 커밋 단계

  렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다.

  이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

**리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다**

렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다.

즉, 가시적인 변경이 일어나지 않아도 렌더링이 발생할 수 있다.

그대신 커밋 단계가 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다.

<br />

---

### 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 API 중 useMemo, useCallback 훅과 고차 컴포넌트인 memo()는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

#### 2.5.1 주장 1 : 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불할 때는 항상 신중해야한다.

```
function sum(a,b){
    return a+b
}
```

sum(1,1)의 결과를 저장해 두고 sum(1,1)이 다시 실행될 때 메모리에서 그 값을 꺼내오는게 나을까? 아님 단순히 자바스크립트에서 1+1을 실행시키는 게 나을까?

메모이제이션은 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다.

과연 이 비용이 리렌더링 비용보다 저렴하다고 할 수 있을까?

렌더링도 비용이지만 메모리에 저장하는 것도 마찬가지로 비용이다.

실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 좋다.

#### 2.5.2 주장 2 : 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자

두 주장의 공통으로 깔고 가는 전제는 **일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다**

잘못된 memo로 지불해야 하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다.

어차피 리액트는 이전 렌더링 결과를 다음 렌더링과 비교하기 위해 이전 결과물들을 저장해두고있다.

따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것이다.

물론 이 비용 또한 무시할 수 없다.

<br />

- memo를 하지 않았을 때 발생할 수 있는 문제

  - 렌더링을 함으로써 발생하는 비용

  - 컴포넌트 내부의 복잡한 로직의 재실행

  - 그리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남

  - 리액트가 구 트리와 신규 트리를 비교

<br />

memo를 하지 않았을 때 치러야 할 잠재적인 위험 비용이 더 크다는 사실을 알 수 있다.

메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있다.

최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.
