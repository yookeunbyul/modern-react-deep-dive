# 리액트 훅 깊게 살펴보기

함수 컴포넌트가 **상태 사용** / 클래스 컴포넌트의 **생명주기 메서드를 대체**하는 등의 다양한 작업을 하기위해 훅이 추가됐다.

### 3.1 리액트의 모든 훅 파헤치기

훅은 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도 가능하게 만듦.

그리고 무엇보다 클래스 컴포넌트보다 간결하게 작성 가능.

<br />

#### 3.1.1 useState

함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

- useState 구현 살펴보기

  ```
  import {useState} from 'react';

  const [state, setState] = useState(initialState)
  ```

  **리액트의 렌더링은 함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행된다**

  함수 컴포넌트는 매번 함수를 실행해 렌더링이 일어나고, 함수의 내부의 값은 함수가 실행될 때마다 다시 초기화된다.

  그래서 useState를 사용하지 않고 상태값을 관리하면 변화가 없다.

  **[클로저는 어떤 함수(useState) 내부에 선언된 함수(setState)가 실행이 종료된 이후에도(useState가 호출된 이후에도) 지역변수인 state를 계속 참조할 수 있다는 것을 의미한다.]**

  리액트는 매번 실행되는 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 위해서 클로저를 활용하고있다.

  ```
  [클로저]

  해당 함수안에 함수를 선언한 환경은 내부 함수에서 외부 함수로 지역변수를 접근할 수 있지만
  외부 함수의 실행이 끝나고 외부 함수가 소멸된 이후에도
  내부 함수가 외부 함수의 변수에 접근할 수 있는 것을 의미합니다.

  이러한 이유가 발생하는 이유는 자바스크립트는 함수를 리턴하고 리턴되는 함수가 클로저를 형성하기 때문에 접근이 가능합니다.
  클로저는 반환된 내부함수가 자신이 선언되었을때의 환경(Lexical Environment)에서의 스코프를 기억하기 때문에 접근이 가능합니다.

  즉, 현재 상태를 기억하고 있다가 상태가 변경되면 그것을 최신 상태로 유지하는 기능으로 사용합니다.
  => 'useState'
  ```

- 게으른 초기화

  useState에서 기본값을 선언하기 위해 useState() 인수로 원시값을 넣는 경우가 대부분.

  그러나 특정한 값을 넘기는 함수를 인수로 넣어줄 수도 있다. => **게으른 초기화**

  ```
  const [count, setCount] = useState(() => Number.parseInt(window.localStorage.getItem(cacheKey)),
  )
  ```

  useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용한다.

  오로지 state가 처음 만들어질 때만 사용되고 이후에 리렌더링이 발생된다면 이 함수의 실행은 무시된다.

<br />

#### 3.1.2 useEffect

useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.

- useEffect란?

  ```
  function Component() {
      useEffect(() => {
          //...do something
      }, [props, state])
  }
  ```

  첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, 두 번째 인수로는 의존성 배열을 전달한다.

  의존성 배열이 변경될 때마다 useEffect의 첫 번째 인수인 콜백을 실행한다.

  ```
  function Component() {
    const [counter, setCounter] = useState(0)

    function handleClick() {
        setCounter((prev) => prev + 1)
    }

    useEffect(() => {
        console.log(counter) //1,2,3,4....
    }, [counter])

    return (
        <>
            <h1>{counter}</h1>
            <button onClick={handelClick}>+</button>
        </>
    )
  }
  ```

  useEffect는 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고 렌더링 할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른게 하나라도 있으면 **부수 효과**를 실행하는 평범한 함수라 볼 수 있다.

- 클린업 함수의 목적

  일반적으로 이 클린업 함수는 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.

  클린업 함수는 새로운 값과 함께 렌더링된 뒤에 실행되기 때문에 이전 state를 참조해 실행된다.

  useEffect는 이전의 클린업 함수가 존재한다면 그 콜백이 실행될 때마다 그 클린업 함수를 실행한 뒤에 콜백을 실행한다. 따라서 이 전에 등록했던 이벤트 핸들러는 삭제하는 코드를 클린업 함수에 추가하는 것이다.

  이렇게 함으로써 이벤트 핸들러가 무한히 추가되는 것을 방지된다.

  즉, 클린업 함수는 언마운트라기보다는 함수 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전 상태를 청소해 주는 개념으로 보는 것이 옳다.

- 의존성 배열

  만약 의존성 배열을 빈 배열을 둔다면 리액트가 이 useEffect는 비교할 의존성이 없다고 판단해 최초 렌더링 직후에 실행된 다음부터는 더 이상 실행되지 않는다.

  아무런 값도 넘겨주지 않는다면, 렌더링이 발생할 때마다 실행된다.

<br />

#### 3.1.3 useMemo(값)

비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다.

```
import {useMemo} from 'react'

const memoizedValue = useMemo(() => expensiveComputation(a,b), [a,b])
```

첫 번째 인수로는 어떠한 값을 반환하는 생성 함수를, 두 번째 인수로는 해당 함수가 의존하는 값의 배열을 전달한다.

useMemo는 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고 이전에 기억해둔 값을 반환하고, 의존성 배열의 값이 변경됐다면 첫 번째 인수의 함수를 실행한 후에 그 값을 반환하고 그 값을 다시 기억해 둘 것이다.

단순한 값뿐만 아니라 컴포넌트도 메모이제이션이 가능하다.

<br />

#### 3.1.4 useCallback(함수)

쉽게 말해 useCallback은 특정 함수를 새로 만들지 않고 다시 재사용한다는 의미다.

특정 함수를 재생성하지 않는다. 컴포넌트가 렌더링이 되면 함수도 역시 재생성이 된다.

**변경되지않으면 리렌더링 X, 재실행 X, 재생성 X**

값의 메모이제이션을 위해 useMemo를 사용했다면, 함수의 메모이제이션을 위해 사용하는 것이 useCallback이다.

useCallback의 첫 번째 인수로 함수를, 두 번째 인수로 의존성 배열을 집어 넣으면 useMemo와 마찬가지로 의존성 배열이 변경되지 않는 한 함수를 재생성하지 않는다.

```
const ChildComponent = memo(({name, value, onChange}) => {
    useEffect(() => {
        console.log('rendering!, name)
    })

    return (
        <>
            <h1>
                {name} {value ? '켜짐' : '꺼짐'}
            </h1>
            <button onClick={onChange}>toggle</button>
        </>
    )
})

function App() {
    const [status1, setStatus1] = useState(false);
    const [status2, setStatus2] = useState(false);

    const toggle1 = useCallback(
        function toggle1() {
            setStatus1(!status1)
        },
        [status1],
    )

    const toggle2 = useCallback(
        function toggle1() {
            setStatus1(!status2)
        },
        [status2],
    )

    return(
        <>
            <ChildComponent name="1" value={status1} onChange={toggle1} />
            <ChildComponent name="2" value={status2} onChange={toggle2} />
        </>
    )
}
```

<br />

#### 3.1.4 useCallback(함수)
